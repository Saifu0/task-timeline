{"ast":null,"code":"const YEAR = 'year';\nconst MONTH = 'month';\nconst DAY = 'day';\nconst HOUR = 'hour';\nconst MINUTE = 'minute';\nconst SECOND = 'second';\nconst MILLISECOND = 'millisecond';\nconst month_names = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\nexport default {\n  parse(date, date_separator = '-', time_separator = ':') {\n    if (date instanceof Date) {\n      return date;\n    }\n\n    if (typeof date === 'string') {\n      let date_parts, time_parts;\n      const parts = date.split(' ');\n      date_parts = parts[0].split(date_separator).map(val => parseInt(val, 10));\n      time_parts = parts[1] && parts[1].split(time_separator); // month is 0 indexed\n\n      date_parts[1] = date_parts[1] - 1;\n      let vals = date_parts;\n\n      if (time_parts && time_parts.length) {\n        vals = vals.concat(time_parts);\n      }\n\n      return new Date(...vals);\n    }\n  },\n\n  to_string(date, with_time = false) {\n    if (!(date instanceof Date)) {\n      throw new TypeError('Invalid argument type');\n    }\n\n    const vals = this.get_date_values(date).map((val, i) => {\n      if (i === 1) {\n        // add 1 for month\n        val = val + 1;\n      }\n\n      return padStart(val + '', 2, '0');\n    });\n    const date_string = `${vals[0]}-${vals[1]}-${vals[2]}`;\n    const time_string = `${vals[3]}:${vals[4]}:${vals[5]}`;\n    return date_string + (with_time ? ' ' + time_string : '');\n  },\n\n  format(date, format_string = 'YYYY-MM-DD HH:mm:ss') {\n    const values = this.get_date_values(date).map(d => padStart(d, 2, 0));\n    const format_map = {\n      YYYY: values[0],\n      MM: padStart(+values[1] + 1, 2, 0),\n      DD: values[2],\n      HH: values[3],\n      mm: values[4],\n      ss: values[5],\n      D: values[2],\n      MMMM: month_names[+values[1]],\n      MMM: month_names[+values[1]]\n    };\n    let str = format_string;\n    const formatted_values = [];\n    Object.keys(format_map).sort((a, b) => b.length - a.length) // big string first\n    .forEach(key => {\n      if (str.includes(key)) {\n        str = str.replace(key, `$${formatted_values.length}`);\n        formatted_values.push(format_map[key]);\n      }\n    });\n    formatted_values.forEach((value, i) => {\n      str = str.replace(`$${i}`, value);\n    });\n    return str;\n  },\n\n  diff(date_a, date_b, scale = DAY) {\n    let milliseconds, seconds, hours, minutes, days, months, years;\n    milliseconds = date_a - date_b;\n    seconds = milliseconds / 1000;\n    minutes = seconds / 60;\n    hours = minutes / 60;\n    days = hours / 24;\n    months = days / 30;\n    years = months / 12;\n\n    if (!scale.endsWith('s')) {\n      scale += 's';\n    }\n\n    return Math.floor({\n      milliseconds,\n      seconds,\n      minutes,\n      hours,\n      days,\n      months,\n      years\n    }[scale]);\n  },\n\n  today() {\n    const vals = this.get_date_values(new Date()).slice(0, 3);\n    return new Date(...vals);\n  },\n\n  now() {\n    return new Date();\n  },\n\n  add(date, qty, scale) {\n    qty = parseInt(qty, 10);\n    const vals = [date.getFullYear() + (scale === YEAR ? qty : 0), date.getMonth() + (scale === MONTH ? qty : 0), date.getDate() + (scale === DAY ? qty : 0), date.getHours() + (scale === HOUR ? qty : 0), date.getMinutes() + (scale === MINUTE ? qty : 0), date.getSeconds() + (scale === SECOND ? qty : 0), date.getMilliseconds() + (scale === MILLISECOND ? qty : 0)];\n    return new Date(...vals);\n  },\n\n  start_of(date, scale) {\n    const scores = {\n      [YEAR]: 6,\n      [MONTH]: 5,\n      [DAY]: 4,\n      [HOUR]: 3,\n      [MINUTE]: 2,\n      [SECOND]: 1,\n      [MILLISECOND]: 0\n    };\n\n    function should_reset(_scale) {\n      const max_score = scores[scale];\n      return scores[_scale] <= max_score;\n    }\n\n    const vals = [date.getFullYear(), should_reset(YEAR) ? 0 : date.getMonth(), should_reset(MONTH) ? 1 : date.getDate(), should_reset(DAY) ? 0 : date.getHours(), should_reset(HOUR) ? 0 : date.getMinutes(), should_reset(MINUTE) ? 0 : date.getSeconds(), should_reset(SECOND) ? 0 : date.getMilliseconds()];\n    return new Date(...vals);\n  },\n\n  clone(date) {\n    return new Date(...this.get_date_values(date));\n  },\n\n  get_date_values(date) {\n    return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];\n  },\n\n  get_days_in_month(date) {\n    const no_of_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    const month = date.getMonth();\n\n    if (month !== 1) {\n      return no_of_days[month];\n    } // Feb\n\n\n    const year = date.getFullYear();\n\n    if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) {\n      return 29;\n    }\n\n    return 28;\n  }\n\n}; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart\n\nfunction padStart(str, targetLength, padString) {\n  str = str + '';\n  targetLength = targetLength >> 0;\n  padString = String(typeof padString !== 'undefined' ? padString : ' ');\n\n  if (str.length > targetLength) {\n    return String(str);\n  } else {\n    targetLength = targetLength - str.length;\n\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n\n    return padString.slice(0, targetLength) + String(str);\n  }\n}","map":{"version":3,"sources":["/home/saifu/Documents/pikkal/saifur-timeline/node_modules/frappe-gantt/src/date_utils.js"],"names":["YEAR","MONTH","DAY","HOUR","MINUTE","SECOND","MILLISECOND","month_names","parse","date","date_separator","time_separator","Date","date_parts","time_parts","parts","split","map","val","parseInt","vals","length","concat","to_string","with_time","TypeError","get_date_values","i","padStart","date_string","time_string","format","format_string","values","d","format_map","YYYY","MM","DD","HH","mm","ss","D","MMMM","MMM","str","formatted_values","Object","keys","sort","a","b","forEach","key","includes","replace","push","value","diff","date_a","date_b","scale","milliseconds","seconds","hours","minutes","days","months","years","endsWith","Math","floor","today","slice","now","add","qty","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","start_of","scores","should_reset","_scale","max_score","clone","get_days_in_month","no_of_days","month","year","targetLength","padString","String","repeat"],"mappings":"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","sourcesContent":["const YEAR = 'year';\nconst MONTH = 'month';\nconst DAY = 'day';\nconst HOUR = 'hour';\nconst MINUTE = 'minute';\nconst SECOND = 'second';\nconst MILLISECOND = 'millisecond';\n\nconst month_names = [\n    'January',\n    'February',\n    'March',\n    'April',\n    'May',\n    'June',\n    'July',\n    'August',\n    'September',\n    'October',\n    'November',\n    'December'\n];\n\nexport default {\n    parse(date, date_separator = '-', time_separator = ':') {\n        if (date instanceof Date) {\n            return date;\n        }\n        if (typeof date === 'string') {\n            let date_parts, time_parts;\n            const parts = date.split(' ');\n\n            date_parts = parts[0]\n                .split(date_separator)\n                .map(val => parseInt(val, 10));\n            time_parts = parts[1] && parts[1].split(time_separator);\n\n            // month is 0 indexed\n            date_parts[1] = date_parts[1] - 1;\n\n            let vals = date_parts;\n\n            if (time_parts && time_parts.length) {\n                vals = vals.concat(time_parts);\n            }\n\n            return new Date(...vals);\n        }\n    },\n\n    to_string(date, with_time = false) {\n        if (!(date instanceof Date)) {\n            throw new TypeError('Invalid argument type');\n        }\n        const vals = this.get_date_values(date).map((val, i) => {\n            if (i === 1) {\n                // add 1 for month\n                val = val + 1;\n            }\n\n            return padStart(val + '', 2, '0');\n        });\n        const date_string = `${vals[0]}-${vals[1]}-${vals[2]}`;\n        const time_string = `${vals[3]}:${vals[4]}:${vals[5]}`;\n\n        return date_string + (with_time ? ' ' + time_string : '');\n    },\n\n    format(date, format_string = 'YYYY-MM-DD HH:mm:ss') {\n        const values = this.get_date_values(date).map(d => padStart(d, 2, 0));\n        const format_map = {\n            YYYY: values[0],\n            MM: padStart(+values[1] + 1, 2, 0),\n            DD: values[2],\n            HH: values[3],\n            mm: values[4],\n            ss: values[5],\n            D: values[2],\n            MMMM: month_names[+values[1]],\n            MMM: month_names[+values[1]]\n        };\n\n        let str = format_string;\n        const formatted_values = [];\n\n        Object.keys(format_map)\n            .sort((a, b) => b.length - a.length) // big string first\n            .forEach(key => {\n                if (str.includes(key)) {\n                    str = str.replace(key, `$${formatted_values.length}`);\n                    formatted_values.push(format_map[key]);\n                }\n            });\n\n        formatted_values.forEach((value, i) => {\n            str = str.replace(`$${i}`, value);\n        });\n\n        return str;\n    },\n\n    diff(date_a, date_b, scale = DAY) {\n        let milliseconds, seconds, hours, minutes, days, months, years;\n\n        milliseconds = date_a - date_b;\n        seconds = milliseconds / 1000;\n        minutes = seconds / 60;\n        hours = minutes / 60;\n        days = hours / 24;\n        months = days / 30;\n        years = months / 12;\n\n        if (!scale.endsWith('s')) {\n            scale += 's';\n        }\n\n        return Math.floor(\n            {\n                milliseconds,\n                seconds,\n                minutes,\n                hours,\n                days,\n                months,\n                years\n            }[scale]\n        );\n    },\n\n    today() {\n        const vals = this.get_date_values(new Date()).slice(0, 3);\n        return new Date(...vals);\n    },\n\n    now() {\n        return new Date();\n    },\n\n    add(date, qty, scale) {\n        qty = parseInt(qty, 10);\n        const vals = [\n            date.getFullYear() + (scale === YEAR ? qty : 0),\n            date.getMonth() + (scale === MONTH ? qty : 0),\n            date.getDate() + (scale === DAY ? qty : 0),\n            date.getHours() + (scale === HOUR ? qty : 0),\n            date.getMinutes() + (scale === MINUTE ? qty : 0),\n            date.getSeconds() + (scale === SECOND ? qty : 0),\n            date.getMilliseconds() + (scale === MILLISECOND ? qty : 0)\n        ];\n        return new Date(...vals);\n    },\n\n    start_of(date, scale) {\n        const scores = {\n            [YEAR]: 6,\n            [MONTH]: 5,\n            [DAY]: 4,\n            [HOUR]: 3,\n            [MINUTE]: 2,\n            [SECOND]: 1,\n            [MILLISECOND]: 0\n        };\n\n        function should_reset(_scale) {\n            const max_score = scores[scale];\n            return scores[_scale] <= max_score;\n        }\n\n        const vals = [\n            date.getFullYear(),\n            should_reset(YEAR) ? 0 : date.getMonth(),\n            should_reset(MONTH) ? 1 : date.getDate(),\n            should_reset(DAY) ? 0 : date.getHours(),\n            should_reset(HOUR) ? 0 : date.getMinutes(),\n            should_reset(MINUTE) ? 0 : date.getSeconds(),\n            should_reset(SECOND) ? 0 : date.getMilliseconds()\n        ];\n\n        return new Date(...vals);\n    },\n\n    clone(date) {\n        return new Date(...this.get_date_values(date));\n    },\n\n    get_date_values(date) {\n        return [\n            date.getFullYear(),\n            date.getMonth(),\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            date.getMilliseconds()\n        ];\n    },\n\n    get_days_in_month(date) {\n        const no_of_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n        const month = date.getMonth();\n\n        if (month !== 1) {\n            return no_of_days[month];\n        }\n\n        // Feb\n        const year = date.getFullYear();\n        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {\n            return 29;\n        }\n        return 28;\n    }\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart\nfunction padStart(str, targetLength, padString) {\n    str = str + '';\n    targetLength = targetLength >> 0;\n    padString = String(typeof padString !== 'undefined' ? padString : ' ');\n    if (str.length > targetLength) {\n        return String(str);\n    } else {\n        targetLength = targetLength - str.length;\n        if (targetLength > padString.length) {\n            padString += padString.repeat(targetLength / padString.length);\n        }\n        return padString.slice(0, targetLength) + String(str);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}